Test date: 11/11/18  25:20:52 
The number of times you used the grading program is 5 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.1
Student: St#1=Choi                 St#2t=Lee                  Type=Team                
Grading program history
   *** Grading Run.  Date: 11/11/18  24:41:06 
   *** Grading Run.  Date: 11/11/18  24:42:35 
   *** Grading Run.  Date: 11/11/18  24:49:17 
   *** Grading Run.  Date: 11/11/18  25:17:23 
   *** Grading Run.  Date: 11/11/18  25:20:52 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++   60 = Points earned for correct answers.

-> A major reason for programming in assembler is to maximize efficiency.
This can be instructions written and/or instructions executed.
Please read the section in the class notes titled Code Complexity.

We are now analyzing your source code. You will be graded on
the number of instructions you wrote to solve this problem.
The target for the number of executable instructions written is:
20 points for   0 -  38  
15 points for  39 -  42  
10 points for  43 -  46 
05 points for  47 -  50 
00 points for  51+      
Your actual counts are:
Lines ....... 149    Comments ...  77    Labels .......   8   
Directives ..   9    Variables ..   7    Executables ..  48    McCabe ..   7 
++ Grade ++    5 = Points earned for code written efficiency.  

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0020 The program header format is adequate. 
DOCHB-1.16 Use of code block headers is adequate. 
DOCLC-0.94 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   85 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     5  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC<6&}xC;&k~C6&juiC86&zuzC>;&Zkyz&jgzk@&7757757>&&8;@86@;8&

Building the file arm.ans for electronic submission...
;---------------------------------------------------------------------
; File:     armkey.s
;
; Function: The program then a reads a line of ASCII text with printable
;           characters and control characters (00h-7Fh) from the file key.in into
;           an input string. The read string ARM SWI will remove any end of line
;           indication or characters and replace them with a single
;           binary 0. If there are no more lines the read string ARM SWI
;           will return a count of zero for the number of bytes read.
;
; Author:   John Choi, Chang Lee
;
; Changes:  Date        Reason
;           ----------------------------------------------------------
;           11/11/2018  Original version
;           11/12/2018  Fix the logic for better efficiency
;---------------------------------------------------------------------

;---------------------------------------------------------------------
; Software Interrupt Values
;---------------------------------------------------------------------
				.equ SWI_Open, 0x66                                         ; Open a file
        .equ SWI_Close, 0x68																				; Close a file
        .equ SWI_PrStr, 0x69																				; Write a null-ending string
        .equ SWI_RdStr, 0x6a																				; Read a string and terminate with null
        .equ SWI_Exit, 0x11																					; Stop execution
;---------------------------------------------------------------------
				.global _start
        .text
;---------------------------------------------------------------------
; Open input file
; - r0 points to the file name
; - r1 0 for input
; - the open swi is 66h
; - after the open r0 will have the file handle
;---------------------------------------------------------------------
_start:                                                             ;
        ldr r0, =InFileName                                         ; r0 points to the input file
        ldr r1, =0                                                  ; r1 = 0 specifies the file is input
        swi SWI_Open                                                ; open the file ... r0 will be the file handle
        ldr r1, =InFileHandle                                       ; r1 points to handle location
        str r0, [r1]                                                ; store the file handle
;---------------------------------------------------------------------

;---------------------------------------------------------------------
; Open output file
; - r0 poins to the file name
; - r1 1 for output
; - the open swi is 66h
; - after the open r0 will have the file handle
;---------------------------------------------------------------------
        ldr r0, =OutFileName                                        ; r0 points to the output file
        ldr r1, =1                                                  ; r1 = 1 specifies the file is output
        swi SWI_Open                                                ; open the file ... r0 will be the file handle
        ldr r1, =OutFileHandle                                      ; r1 points to the handle location
        str r0, [r1]                                                ; store the file handle
;---------------------------------------------------------------------

;---------------------------------------------------------------------
; read a string from the input file
; - r0 contains the file handle
; - r1 points to the input string buffer
; - r2 contains the max number of characters to read
; - the read swi is 6ah
; - the input string will be terminated with 0
;---------------------------------------------------------------------
read:                                                               ;
        ldr r0, =InFileHandle                                       ; r0 points to the input file handle
        ldr r0, [r0]                                                ; r0 has the input file handle
        ldr r1, =InString                                           ; r1 points to the input string
        ldr r2, =80                                                 ; allocate 80 bytes for single string
        swi SWI_RdStr                                               ; read a string from the input file
				cmp r0, #00
				beq _exit
;---------------------------------------------------------------------
; Store pointers to input string and output string
;---------------------------------------------------------------------
        ldr r0, =InString                                           ; r0 points to the input string
        ldr r1, =OutString                                          ; r1 points to the output string
;---------------------------------------------------------------------
; Continue getting single string/line from the input file until
; it hits eof
;---------------------------------------------------------------------
loop:
			  ldrb r3, [r0], #1                                           ; store whats in r0 to r3 and increment pointer
;---------------------------------------------------------------------
; filter the character using substraction to check it is upper case alphabet or not.
;---------------------------------------------------------------------
cal:
			 	 cmp  r3, #0x5A                                             ;compare input chacter with 5Ah, 'Z' in acii
     	   ble keep                                                   ;if character is less or equal to 'Z', jump to keep.
     	   sub  r3, r3, #0x20                                         ;Substract 20h from the character so lower case can become uppercase
     	   bal cal                                                    ;Once subtraction is done, back to check so that I do not need to write another instruction
;---------------------------------------------------------------------
; This checks special characters besides alphabet, blank, null, and check alphabet at the end
;---------------------------------------------------------------------
keep:
			   cmp r3, #0x20                                              ;compare character if it's 20h which is space in ascii
			 	 beq buffer                                                 ;If a character is space, jump to buffer which is a section to fill the buffer
         cmp r3, #0x00                                              ;compare character if it's 00h which is period in ascii
         beq buffer                                                 ;If a character is 00, jump to buffer which is a section to fill the buffer
         cmp r3, #0x41                                              ;compare character if it's 41h which is A in ascii
         bge buffer                                                 ;If a character is bigger than or equal to 41h, jump to print which is a section to fill the buffer
         bal loop                                                   ;otherwise check another character
;---------------------------------------------------------------------
; At this point, letter is valid so store it to the output string
;---------------------------------------------------------------------
buffer:
				strb r3, [r1], #1																						; Store it to the output string
        cmp r3, #0x00																								; Is it end of file signal?
        bne loop																										; If not, get another letter
;---------------------------------------------------------------------
; Write the outputs string
;---------------------------------------------------------------------
_write:																															;
        ldr r0, =OutFileHandle																			; r0 points to the output file handle
        ldr r0, [r0]																								; r0 has the output file handle
        ldr r1, =OutString																					; r1 points to the output string
				swi SWI_PrStr																								; write the null terminated string
        ldr r1, =CRLF																								; load CRLF to r1
        swi SWI_PrStr																								; print CRLF
        bal read																										; read another line/string
;---------------------------------------------------------------------
; Close input and output files
; Terminate the program
;---------------------------------------------------------------------
_exit:																														  ;
        ldr r0, =InFileHandle																				; r0 points to the input file handle
        ldr r0, [r0]																								; r0 has the input file handle
        swi SWI_Close																								; close the file
																																		;
        ldr r0, =OutFileHandle																			; r0 points to the output file handle
        ldr r0, [r0]																								; r0 has the output file handle
        swi SWI_Close																								; close the file
																																		;
        swi SWI_Exit																								; terminate the program

        .data
;---------------------------------------------------------------------
InFileHandle: .skip 4																								; 4 byte field to hold the input file handle
OutFileHandle: .skip 4																							; 4 byte field to hold the output file handle
InFileName: .asciz "KEY.IN"																					; Input file name, null terminated
InString: .skip 128																									; reserve 128 byte string for the input
OutString: .skip 128																								; reserve 128 byte string for the output
CRLF: .byte 13, 10, 0																								; CR LF
OutFileName: .asciz "KEY.OUT"																				; Output file name, null terminated
;---------------------------------------------------------------------

				.end
