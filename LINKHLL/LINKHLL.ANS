Test date: 10/27/18  20:50:40 
The number of times you used the grading program is 1 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
Linkhll Grading System Version 4.0
Student: Last=Choi                 First=John                 Type=Individual          
Grading and testing history log
       User Test.    Date: 10/27/18  20:02:12  user_test    testout      
       User Test.    Date: 10/27/18  20:05:45  user_test    testout      
       User Test.    Date: 10/27/18  20:43:22  user_test    testout      
       User Test.    Date: 10/27/18  20:50:26  user_test    testout      
   *** Grading Run.  Date: 10/27/18  20:50:40 

++ Grade ++   60 = Points earned for correct answers.

+  Your executed instruction count per call is = 00022
+   
+  Target instructions executed per call is:
+  20 points 01 - 18 
+  15 points 19 - 20 
+  10 points 21 - 22 
+   5 points 23 - 24 
+   0 points 25+      
+                     
++ Grade ++   10 = Points earned for code executed efficiency!

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0023 The program header format is adequate. 
DOCHB-1.13 Use of code block headers is adequate. 
DOCLC-1.00 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   90 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     4  = Number of user tests.                                  
     1  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC<6&}xC6&k~C76&juiC86&zuzC?6&Zkyz&jgzk@&7658=57>&&86@;6@:6&

Building the file linkhll.ans for electronic submission...

;--------------------------------------------------------------------
;   LINKHLL ***** MASM VERSION *****
;
;
;   LINKHLL.  The linkhll subroutine is a C/C++ subroutine
;   and will be linked with a C/C++ main program. The linkhll
;   subroutine will be passed four unsigned words on the stack
;   (these are passed by value). Linkhll is to find the two largest
;   unsigned values and multiply them creating a 32 bit unsigned
;   product.
;
;
;       Input:
;             v1, v2, v3, v4 16-bit unsigned values from driver program.
;       Output:
;             Product of max value and min value in 32-bit, dx:ax pair
;             register
;
;   Author:   John Choi
;
;   Date:     Changes
;   09/22/18  original version
;---------------------------------------
         .model     small              ; 64k code and 64k data
         .8086                         ; only allow 8086 instructions
         public     _linkhll           ; allow external programs to call
;---------------------------------------
         .code                         ; start the code segment
;---------------------------------------
; Starting point of this subroutine.
; Save bp register and initialize ax and bx values
; to param1 and param2
;---------------------------------------
_linkhll:
        push bp                        ; save caller's bp
        mov  bp, sp                    ; init bp so we can get the arguments
        mov  ax, [bp + 4]              ; assign param1 to max
        mov  bx, [bp + 6]              ; assign param2 to secondMax
        cmp  ax, bx                    ; if ax is less than bx
        ja   firstCmp                  ; jump to else statement
        mov  ax, [bp + 6]              ; swap if
        mov  bx, [bp + 4]              ; else
;---------------------------------------
; Portion of the code where first comparison
; happens.
; Compares if param3 is greater than ax, first maximum
;---------------------------------------
firstCmp:
        cmp  [bp + 8], ax              ; if param3 is greater than ax
        jb   secondCmp                 ; (if param3 is less than ax)
        mov  bx, ax                    ; go here and assign bx to ax and
        mov  ax, [bp + 8]              ; assign ax to param3
        jmp  fifthCmp                  ; compare param4 if param4 is greater than ax
;---------------------------------------
; Portion of the code where second comparison
; happens.
; This is the else if part of the if-else
; statement.
;---------------------------------------
secondCmp:                             ; (go here)
        cmp  [bp + 8], ax              ; else if param3 is less than ax and
        ja   fifthCmp                  ; (if param3 is greater than ax)
        cmp  [bp + 8], bx              ; param3 is greater than bx
        jb   fifthCmp                  ; <if param3 is less than bx>
        mov  bx, [bp + 8]              ; assign param3 to bx
;---------------------------------------
; Portion of the code where if-else statement
; happens.
; This part handles the case where param3 is
; less than bx.
;---------------------------------------
fifthCmp:                              ; (<go here>)
        cmp  [bp + 10], ax             ; if param4 is greater than ax
        jb   seventhCmp                ; (if param4 is less than ax)
        mov  bx, ax                    ; go here and assign bx to ax and
        mov  ax, [bp + 10]             ; assign ax to param4
        jmp  calculate                 ; jump to calculate if param4 is greater than ax
;---------------------------------------
; Portion of the code where if-else statement
; happens.
; This part handles the case where
; param4 is greater than ax.
; Contains else statement.
;---------------------------------------
seventhCmp:                            ; (go here)
        cmp  [bp + 10], ax             ; else if param4 is less than ax and
        ja   calculate                 ; (if param4 is greater than ax)
        cmp  [bp + 10], bx             ; param4 is greater than bx
        jb   calculate                 ; <if param4 is less than bx>
        mov  bx, [bp + 10]             ; assign bx to param4
;---------------------------------------
; Portion of the code where the actual
; calculation happens.
; AX register is first max value, BX register
; holds the second max value.
; Stores the result in dx:ax register
;---------------------------------------
calculate:                             ; (<go here>)
        mul  bx                        ; multiply max and min and store in dx:ax
;---------------------------------------
; Restore registers and return.
;---------------------------------------
exit:
        pop  bp                        ; restore bp
        ret                            ; return
;---------------------------------------
; End the subroutine and return to main program
;---------------------------------------
        end                            ; finish the program
;---------------------------------------
